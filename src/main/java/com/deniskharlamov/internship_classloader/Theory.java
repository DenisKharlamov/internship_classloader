package com.deniskharlamov.internship_classloader;

public class Theory {
	
	/*
	 * 		Загрузчик классов -> используется для поставки в JVM скомпилированного
	 * байт кода, который хранится в файлах с расширением .class, но может
	 * быть также получен из других источников, например, загружен по сети
	 * или же сгенерирован самим приложением.
	 * 
	 * 		Согласно спецификации Java SE для того, чтобы получить работающий 
	 * JVM код, необходимо выполнить 3 этапа:
	 * 
	 * 		-> загрузка байт-кода из ресурсов и создание экземпляра класса
	 *         Class
	 *         
	 *      сюда входит поиск запрошенного класса среди загруженных ранее,
	 *      получение байт-кода для загрузки и проверка его корректности,
	 *      создание экземпляра класса Class (для работы с ним в runtime),
	 *      загрузка родительских классов. Если родительские классы и
	 *      интерфейсы не были загружены, то и рассматриваемый класс
	 *      считается не загруженным.
	 *      
	 *      -> связывание (или линковка)
	 *      
	 *      по спецификации этот этап рабит еще на три стадии:
	 *      
	 *      	-> Verification, происходит проверка корректности полученного байт-кода
	 *      
	 *      	-> Preparation, выделение оперативной памяти под статические поля и
	 *      	   инициализация их значениями по умолчанию(при этом явная инициализация,
	 *      	   если она есть, происходит уже на этапе инициализации)
	 *      	-> Resolution, разрешение символьных ссылок типов, полей и методов
	 *      
	 *      -> инициализация полученного объекта
	 *      
	 * 		Все эти этапы выполняются последовательно со следующими требованиями:
	 * 
	 * 			-> Класс должен быть загружен прежде чем слинкован
	 * 			
	 * 			-> Класс должен быть полностью проверен и подготовлен прежде,
	 * 			   чем проинициализирован
	 * 
	 * 			-> Ошибки разрешения ссылок происходят во время выполнения
	 * 			   программы, даже если были обнаружены на этапе линковки
	 * 
	 * 		В Java реализована отложенная(ленивая) загрузка классов. А это значит
	 * что загрузка классов ссылочных полей загружаемого класса не будет
	 * выполняться до тех пор, пока в приложении не встретится явное к ним обращение.
	 * Иными словами, разрешение символьных ссылок не обязательно и по умолчанию
	 * не происходит. Тем не менее, в реализации JVM может использоваться и энергичная 
	 * загрузка классов, т.е. все символьные ссылки должны быть учтены сразу. Вот для
	 * этого пункта и действует последнее требование.
	 * 
	 * 			Типы загрузчиков Java:
	 * 			=====================
	 * 
	 * 		В Java существует три стандартных загрузчика, каждый из которых осуществляет
	 * загрузку класса из определенного места:
	 * 
	 * 		-> Bootstrap - базовый загрузчик, также называется Primordial ClassLoader
	 * 			загружает стандартные классы JDK из архива rt.jar
	 * 
	 * 		-> Extension ClassLoader - загрузчик расширений, загружает классы расширений
	 * 			которые по умолчанию находятся в каталоге jre/lib/ext, но могут быть
	 * 			заданы системным свойством java.ext.dirs
	 * 
	 * 		-> System ClassLoader - системный загрузчик, загружает классы приложения,
	 * 			определенные в переменной среды окружения CLASSPATH
	 * 
	 * 		В Java используется иерархия загрузчиков классов, где корневым, является базовый.
	 * Далее следует загрузчик расширений, а за ним уже системный. Каждый загрузчик хранит
	 * указатель на родительский для того, чтобы делегировать ему загрузку в том случае
	 * если сам будет не в состоянии загрузить класс.
	 * 
	 * 		Абстрактный класс ClassLoader
	 * 		=============================
	 * 
	 * 		Каждый загрузчик, за исключением базового, является потомком абстрактного класса
	 * java.lang.ClassLoader. Например реализацией загрузчика расширений является класс
	 * sun.misc.Launcher$ExtClassLoader, а системного загрузчика - sun.misc.Launcher$AppClassLoader.
	 * Базовый загрузчик является нативным и его реализация включена в JVM. Любой класс,
	 * который расширяет java.lang.ClassLoader, может предоставлять свой способ загрузки
	 * классов.
	 * 
	 * 			public abstract class ClassLoader {
	 * 				public Class<?> loadClass(String name);
	 * 				protected Class<?> loadClass(String name, boolean resolve);
	 * 				protected final Class<?> findLoadedClass(String name);
	 * 				public final ClassLoader getParent();
	 * 				protected Class<?> findClass(String name);
	 * 				protected final void resolveClass(Class<?> c);
	 * 
	 * 		loadClass(String name) - является точкой входа для загрузки классов. Его
	 * реализация сводится к вызову другого protected метода loadClass(String name, boolean resolve),
	 * его и необходимо переопределить.
	 * 		В Javadoc написано следующее - на вход подаются два параметра. Один это полное
	 * квалифицированное имя класса, который необходимо загрузить. Второй параметр - флаг,
	 * определяющий, требуется ли выполнять процедуру разрешения символьных ссылок. По
	 * умолчанию он равен false, что означает использование ленивой загрузки классов.
	 * Далее, в реализации метода по умолчанию происходит вызов findLoadedClass(String name),
	 * который проверяет, был ли класс уже загружен ранее и если это так, вернет ссылку
	 * на этот класс. Иначе будет вызван метод загрузки класса у родительского загрузчика.
	 * Если не один из загрузчиков не смог найти загрузенный класс, каждый из них,
	 * следуя в обратном порядке, попытается этот класс найти и загрузить, переопределяя
	 * метод findClass(String name). И наконец, в последнюю очередь, после того как класс удалось
	 * загрузить, в зависимости от флага resolve будет решено стоит ли выполнять загрузку
	 * классов по символьным ссылкам. Явный пример того, что стадия Resolution может
	 * быть вызвана на этапе загрузки класса.
	 * 		Также в Java поддерживается понятие текущего загрузчика классов --> тот загрузчик
	 * который загрузил класс, выполняющийся в данный момент. Каждый класс знает каким
	 * загрузчиком он был загружен --> MyClass.class.getClassLoader(). Для всех классов
	 * приложения текущий загрузчик системный.
	 * 
	 * 			Три принципа загрузки классов
	 * 			=============================
	 * 
	 * 		-> Делегирование
	 * 
	 * 			Запрос на загрузку класса передается родительскому загрузчику, и попытка
	 * 			загрузить класс самостоятельно выполняется, только если родительский 
	 * 			загрузчик не смог найти и загрузить класс. Такой подход позволяет загружать 
	 * 			классы тем загрузчиком, который максимально близко находится к базовому.
	 * 			Так достигается максимальная область видимости классов. Каждый загрузчик
	 * 			ведет учет классов, которые были загружены именно им, помещая их в свой
	 * 			кэш. Множество этих классов и называется областью видимости.
	 * 
	 * 		-> Видимость
	 * 
	 * 			Загрузчик видит только свои классы и классы родителя и понятия не имеет 
	 * 			о классах которые были загружены его потомком.
	 * 
	 * 		-> Уникальность
	 * 
	 * 			Класс может быть загружен только однажды. Механизм делегирования позволяет
	 * 			убедится, что загрузчик, инициирующий загрузку класса, не перегрузит
	 * 			загруженный ранее в JVM класс.
	 * 
	 * 				Схема загрузки классов
	 * 				======================
	 * 
	 * 		Когда происходит вызов загрузки какого-либо класса, происходит поиск этого 
	 * класса в кэше уже загруженных классов текущего загрузчика. Если желаемый класс еще 
	 * не загружался ранее, по принципу делегирования управление передается родительскому 
	 * загрузчику, который находится по иерархии на уровень выше. Родительский загрузчик 
	 * также пытается найти желаемый класс у себя в кэше. Если класс уже был загружен и 
	 * загрузчик знает о его местонахождении, то будет возвращен объект Class этого класса. 
	 * Если нет, поиск будет продолжаться до тех пор, пока не дойдет до базового загрузчика. 
	 * Если и в базовом загрузчике нет информации об искомом классе (т.е. он еще не был 
	 * загружен), будет выполнен поиск байт-кода этого класса по расположению классов, 
	 * о котором знает данный загрузчик, и, если загрузить класс не удастся, управление 
	 * вернется обратно загрузчику-потомку, который будет пытаться выполнить загрузку 
	 * из известных ему источников. Как уже упоминалось выше, расположение классов для 
	 * базового загрузчика это библиотека rt.jar, для загрузчика расширений – каталог 
	 * с расширениями jre/lib/ext, для системного – CLASSPATH, для пользовательского 
	 * это может быть что-то свое.
	 * 
	 * 		Таким образом, ход загрузки классов идет в обратном направлении - от 
	 * корневого загрузчика до текущего. Когда байт-код класса найден, происходит 
	 * загрузка класса в JVM и получение экземпляра типа Class.
	 */
}