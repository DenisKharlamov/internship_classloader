package com.deniskharlamov.internship_classloader;

public class DescriptionClassloader {

	/*
	 * ClassLoader обеспечивает загрузку классов Java. Точнее обеспечивают загрузку
	 * его наследники, конкретные загрузчики классов - сам ClassLoader абстрактен.
	 * Каждый раз когда загружается какой-либо .class файл, например, вследствии
	 * обращения к конструктору или статическому методу соответствующего класса - на
	 * самом деле это действие выполняет один из наследников класса ClassLoader.
	 * 
	 * Существует стандартный вариант реализации ClassLoader - так называемый
	 * системный загрузчик классов. Этот загрузчик используется по умолчанию при
	 * запуске приложений Java командой - java имя_главного_класса. Системный
	 * загрузчик классов реализует стандартный алгоритм загрузки из каталогов и
	 * JAR-файлов, перечисленных в переменной CLASSPATH (переменной среды либо
	 * параметре «-cp» утилиты «java»), а также из JAR-файлов, содержащих
	 * стандартные системные классы вроде java.lang.String и входящих в любой
	 * комплект поставки Java.
	 * 
	 * Одна из замечательных особенностей языка Java заключается в том, что можно
	 * реализовать свой собственный загрузчик классов – наследник ClassLoader – и
	 * использовать его вместо системного.
	 * 
	 * Реализуя наследников ClassLoader, можно полностью контролировать процесс
	 * загрузки абсолютно всех Java-классов. Можно загружать их из любого источника,
	 * к примеру, из собственной системы каталогов, не отраженной в CLASSPATH, из
	 * базы данных или из Internet. Можно предоставить загрузку стандартных
	 * библиотечных классов системному загрузчику, но при этом проконтролировать
	 * факт обращения к ним. При желании можно даже сконструировать байт-код класса
	 * в памяти и после этого работать с ним, как с нормальным классом, загруженным
	 * из «добропорядочного» .class-файла. Среди компилируемых языков подобные
	 * возможности встречаются разве что в ассемблере.
	 * 
	 * Единственное, что нельзя сделать с помощью ClassLoader'a – это создать новый
	 * класс, не располагая его байт-кодом. Для создания нового класса необходимо
	 * получить корректный байт-код класса (образ в памяти обычного .class-файла) в
	 * виде массива byte[]. Затем его нужно передать специальному стандартному
	 * методу ClassLoader.defineClass, который «превратит» его в готовый класс –
	 * объект типа Class.
	 * 
	 * Основной способ работы с классом ClassLoader - это реализация наследников от
	 * него. в системе всегда существует по крайней мере один готовый наследник
	 * ClassLoader – системный загрузчик. Его всегда можно получить с помощью вызова
	 * ClassLoader.getSystemClassLoader().Когда запускается приложение Java с
	 * помощью стандартной команды, виртуальная машина Java первым делом создает
	 * системный загрузчик, загружает с его помощью .class-файла вашего главного
	 * класса и вызывает статический метод вашего класса, соответствующий
	 * объявлению: public static void main(String[] args).
	 * 
	 * Java – язык с отложенной загрузкой кода. Первоначально загружается только
	 * один класс – тот, который передан в качестве параметра утилите «java». Как
	 * только код этого класса обращается к какому-то другому классу (любым
	 * способом: вызовом конструктора, обращением к статическому методу или полю),
	 * загружается другой класс. По мере выполнения кода, загружаются всё новые и
	 * новые классы. Ни один класс не загружается до тех пор, пока в нем не
	 * возникнет реальная потребность. Такое поведение заложено в стандартный
	 * системный загрузчик. Главный класс приложения всегда загружается системным
	 * загрузчиком.
	 * 
	 * В Java поддерживается понятие «текущего» загрузчика классов. Текущий
	 * загрузчик – это тот загрузчик классов (экземпляр некоторого наследника
	 * ClassLoader), который загрузил класс, код которого исполняется в данный
	 * момент. Каждый класс «помнит» загрузивший его загрузчик. Загрузчик,
	 * загрузивший некоторый класс, всегда можно узнать, вызвав метод getClassLoader
	 * у объекта типа Class.
	 * 
	 * Когда возникает необходимость загрузить другой класс вследствие обращения к
	 * его конструктору, статическому методу или полю, виртуальная Java-машина
	 * автоматически обращается к текущему загрузчику классов, о котором «помнит»
	 * текущий исполняемый класс. При этом другой класс также «запоминает» этот
	 * загрузчик в качестве текущего. Иначе говоря, текущий загрузчик, загрузивший
	 * данный класс, по умолчанию наследуется всеми классами, прямо или косвенно
	 * вызываемыми из данного.
	 * 
	 * Так как главный класс приложения обычно загружается системным загрузчиком, то
	 * он же используется и для загрузки всех остальных классов, необходимых
	 * приложению.
	 * 
	 * Стандартный способ загрузить некоторый класс загрузчиком, отличным от
	 * текущего – специальная версия статического метода Class.forName: 
	 * public static Class forName(String name, boolean initialize, ClassLoader loader); 
	 * В качестве name передается полное имя класса (с указанием пакета), в качестве
	 * loader – требуемый загрузчик. Не столь очевидный (и не столь важный) параметр
	 * initialize управляет инициализацией класса, т.е. установкой значений всех
	 * static-полей класса и исполнением кода в секциях: static{}. Если значение
	 * initialize равно true, то инициализация происходит немедленно, в противном
	 * случае – откладывается до первого обращения к любому конструктору,
	 * статическому методу или полю этого класса.
	 * 
	 * Загрузив класс, можно создать его экземпляр или вызвать статический метод
	 * средствами отражений. Дальше этот класс может обычными средствами языка Java
	 * обращаться к другим классам – для них будет вызван тот же самый загрузчик
	 * loader (либо какие-то другие загрузчики, если реализация loader в какой-то
	 * момент «решит» передать управление другому загрузчику). Простейший пример:
	 * 
	 * Class class_= Class.forName("Имя_класса", true, нестандартный_загрузчик);
	 * class_.newInstance(); // создается экземпляр класса
	 * 
	 * 		Методы класса ClassLoader:
	 * public static ClassLoader getSystemClassLoader();
	 * 		// возвращает ссылку на стандартный системный загрузчик
	 * public Class loadClass(String name)
	 * 		// загружает класс с заданным именем
	 * protected synchronized Class loadClass(String name, boolean resolve)
	 * 		// переопределение этого метода один из основных способов для
	 * 		// реализации собственного загрузчика классов.
	 * 
	 * Судя по всему, следует все же всегда использовать вызов Class.forName. Хотя 
	 * это совершенно не очевидно из документации. Метод Class.forName выполняет 
	 * с классом некоторые дополнительные действия, в частности, кэширует его, 
	 * обеспечивая, в отличие от прямого вызова loadClass, стабильную работу даже 
	 * при недостаточно аккуратной реализации загрузчика loader.
	 * 
	 * Имеется также группа public методов, предназначенных для загрузки ресурсов:
	 * 	
	 * 		public URL getResource(String name);
	 *		public InputStream getResourceAsStream(String name);
	 *		public final Enumeration getResources(String name);
	 *		public static URL getSystemResource(String name);
	 *		static InputStream getSystemResourceAsStream(String name);
	 *		static Enumeration getSystemResources(String name);
	 *
	 * Методы Class.getResource и Class.getResourceAsStream обращаются к соответствующим 
	 * методам текущего загрузчика, загрузившего данный класс. Главное отличие методов 
	 * работы с ресурсами класса ClassLoader – абсолютные пути. Путь к ресурсу отсчитывается 
	 * не от каталога, содержащего данный class-файл (как в случае Class.getResource и 
	 * Class.getResourceAsStream), а от одного из каталогов, указанных в переменной CLASSPATH.
	 * Следует обратить внимание, что названия методов getSystemResource, 
	 * getSystemResourceAsStream, getSystemResources не означают, что загружаются какие-то 
	 * особые «системные» ресурсы. Слово «System» в этих названиях говорит о том, что 
	 * для загрузки ресурсов будет в любом случае использоваться стандартный системный 
	 * загрузчик. Любая реализация ClassLoader должна обеспечивать работоспособность 
	 * перечисленных методов.
	 * 
	 * ----------------------------------------------------------------------------------
	 * На самом деле виртуальная машина Java «считает» классом как раз то, что для 
	 * нас является версией. Хотя это и неочевидно из документации, но класс в Java 
	 * однозначно идентифицируется не только полным именем, но еще и экземпляром загрузчика, 
	 * загрузившего этот класс. Каждый экземпляр загрузчика классов порождает собственное 
	 * пространство имен, внутри которого классы действительно однозначно идентифицируются 
	 * полными именами, но классы в разных пространствах имен, загруженные разными загрузчиками, 
	 * вполне могут иметь идентичные имена.
	 * ----------------------------------------------------------------------------------
	 * 
	 */
}





